<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Arturo Bouzas">

<title>Notas de Aprendizaje y Comportamiento Adaptable - 11&nbsp; Comportamiento de Elección: Maximización Local</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./Capítulo 9.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": true,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 10,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Capítulo 10.html"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Comportamiento de Elección: Maximización Local</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./cover.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Notas de Aprendizaje y Comportamiento Adaptable</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/arbouria/Notas-Aprendizaje-y-Comportamiento-Adaptable-I" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Notas-de-Aprendizaje-y-Comportamiento-Adaptable.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
      </ul>
    </div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Alternar modo oscuro"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Notas de Aprendizaje y Comportamiento Adaptable</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introducción</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Capítulo 1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Principios de la Selección Natural</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Capítulo 2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evolución de la Adaptabilidad del Comportamiento: El papel de las restricciones</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Capítulo 3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Asignación de Crédito</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Capítulo 4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Asignación de Crédito para Respuestas</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Capítulo 5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Correlación, Tiempo y Contingencia</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Capítulo 6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Modelo de Aprendizaje por Refuerzo</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Capítulo 7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">El Modelo de Rescorla y Wagner</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Capítulo 8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Acción Como Elección</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Capítulo 9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Elección Recurrente: Igualación</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Capítulo 10.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Comportamiento de Elección: Maximización Local</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referencias</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contenido</h2>
   
  <ul>
  <li><a href="#maximización-momentánea" id="toc-maximización-momentánea" class="nav-link active" data-scroll-target="#maximización-momentánea"><span class="header-section-number">11.1</span> Maximización Momentánea</a>
  <ul class="collapse">
  <li><a href="#evaluación-experimental-del-modelo-de-maximización-momentánea" id="toc-evaluación-experimental-del-modelo-de-maximización-momentánea" class="nav-link" data-scroll-target="#evaluación-experimental-del-modelo-de-maximización-momentánea"><span class="header-section-number">11.1.1</span> Evaluación experimental del modelo de maximización momentánea</a></li>
  <li><a href="#conclusiones-acerca-del-modelo-de-maximización-instantánea" id="toc-conclusiones-acerca-del-modelo-de-maximización-instantánea" class="nav-link" data-scroll-target="#conclusiones-acerca-del-modelo-de-maximización-instantánea"><span class="header-section-number">11.1.2</span> Conclusiones acerca del modelo de maximización Instantánea</a></li>
  </ul></li>
  <li><a href="#modelo-de-mejoramiento" id="toc-modelo-de-mejoramiento" class="nav-link" data-scroll-target="#modelo-de-mejoramiento"><span class="header-section-number">11.2</span> Modelo de Mejoramiento</a></li>
  <li><a href="#modelo-de-valor-q-de-la-respuesta" id="toc-modelo-de-valor-q-de-la-respuesta" class="nav-link" data-scroll-target="#modelo-de-valor-q-de-la-respuesta"><span class="header-section-number">11.3</span> Modelo de Valor <em>Q</em> de la respuesta</a></li>
  <li><a href="#reflexiones-finales-sobre-los-modelos-de-elección-basados-en-valor" id="toc-reflexiones-finales-sobre-los-modelos-de-elección-basados-en-valor" class="nav-link" data-scroll-target="#reflexiones-finales-sobre-los-modelos-de-elección-basados-en-valor"><span class="header-section-number">11.4</span> Reflexiones Finales Sobre los Modelos de Elección Basados en Valor</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/arbouria/Notas-Aprendizaje-y-Comportamiento-Adaptable-I/edit/main/Capítulo 10.qmd" class="toc-action"><i class="bi bi-github"></i>Editar esta página</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Comportamiento de Elección: Maximización Local</span></h1>
</div>



<div class="quarto-title-meta column-body">

    <div>
    <div class="quarto-title-meta-heading">Autor/a</div>
    <div class="quarto-title-meta-contents">
             <p>Arturo Bouzas </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>En el capítulo anterior, vimos que estudiando una medida agregada de respuestas y refuerzos, en equilibrio, la tasa relativa de respuestas tiende a igualar a la tasa de refuerzo que produce cada opción. Contemplamos dos posibles explicaciones computacionales para este fenómeno: la igualación de la probabilidad de refuerzo para las opciones de respuesta (igualación de la rentabilidad de las respuestas) y la maximización de la tasa global de refuerzo.</p>
<p>Una alternativa a estos modelos molares son los modelos de <em>maximización local</em>, los que asumen que igualación es el resultado de que en cada oportunidad de respuesta, los organismos eligen aquella respuesta asociada con el valor más alto de alguna variable local. Vamos a revisar tres miembros de esta familia de modelos, que se distinguen entre ellos por la variable local que cada uno maximiza:</p>
<ul>
<li><em>Maximización Momentánea</em>: Modelos de elección basados en las probabilidades instantáneas de refuerzo de cada alternativa.</li>
<li><em>Mejoramiento</em>: Modelos de elección basados en las tasas locales de refuerzo asociadas con cada alternativa.</li>
<li><em>Valor Q de la respuesta</em>.</li>
</ul>
<section id="maximización-momentánea" class="level2" data-number="11.1">
<h2 data-number="11.1" class="anchored" data-anchor-id="maximización-momentánea"><span class="header-section-number">11.1</span> Maximización Momentánea</h2>
<p>Este modelo asume que los organismos computan las probabilidades locales de refuerzo asociadas con cada respuesta. Consideren un programa concurrente IV - IV. En esos programas, la probabilidad de un refuerzo para una respuesta en cada tecla es una función del tiempo transcurrido desde la última visita a una de ellas. Conforme incrementa el tiempo de estancia en una opción, incrementa la probabilidad de un refuerzo para la respuesta en la opción alterna. Este modelo fue propuesto por Shimp en 1969, quien argumentó que el cambio de una opción a otra era controlado por los cambios en la probabilidad de refuerzo asociados con el tiempo transcurrido en cada opción. Para él, la igualación global era el resultado de una regla de respuesta seguida por el organismo en la cual este respondía a la tecla que tuviera la mayor probabilidad de refuerzo al momento de la elección. Simulando este modelo, Shimp encontró que a nivel global este algoritmo resulta efectivamente en tasas de respuesta iguales a las tasas de refuerzo: reproduciendo así el patrón de igualación.</p>
<section id="evaluación-experimental-del-modelo-de-maximización-momentánea" class="level3" data-number="11.1.1">
<h3 data-number="11.1.1" class="anchored" data-anchor-id="evaluación-experimental-del-modelo-de-maximización-momentánea"><span class="header-section-number">11.1.1</span> Evaluación experimental del modelo de maximización momentánea</h3>
<section id="programas-de-refuerzo-concurrente-iv---iv-de-ensayos-discretos" class="level4" data-number="11.1.1.1">
<h4 data-number="11.1.1.1" class="anchored" data-anchor-id="programas-de-refuerzo-concurrente-iv---iv-de-ensayos-discretos"><span class="header-section-number">11.1.1.1</span> 1. Programas de refuerzo concurrente IV - IV de ensayos discretos</h4>
<p>Empíricamente, el modelo de maximización instantánea predice regularidades en la estructura de los cambios del organismo de una opción a otra después de ciertas secuencias de respuesta. Si se computan las probabilidades de refuerzo de cada una de las opciones de respuesta, es posible determinar cuál respuesta debe seguir después de una secuencia de <em>n</em> respuestas consecutivas en una misma opción. La forma más accesible de estudiar esta predicción es empleando procedimientos de programas de refuerzo concurrentes IV - IV, pero de ensayos discretos. En estos programas, al animal se le presenta la oportunidad de elegir entre dos alternativas con una sola respuesta. Las dos opciones se presentan durante un breve periodo de tiempo. Después de una respuesta a alguna de las dos alternativas, inicia un breve intervalo entre ensayos sin opción de respuesta: al final de este intervalo, al organismo se le presenta una vez más una breve oportunidad para elegir entre una de las dos respuestas. Lo que es importante tener presente frente a estos protocolos es que los programas de refuerzo siguen corriendo durante los intervalos entre ensayos como si no hubiese discontinuidades en el tiempo. Al igual que en los programas IV - IV que hemos revisado, una vez que un refuerzo está disponible para una de las opciones, el reloj del programa IV se detiene y el refuerzo se guarda hasta que es recogido por el animal. Con este protocolo, mientras mayor es el número de elecciones repetidas por una de las opciones, mayor es la probabilidad de que un refuerzo esté esperando en la opción alterna.</p>
<p>En experimentos con programas de ensayos discretos, se mide la probabilidad de cambiar de alternativa después de varias secuencias de respuesta a una misma tecla. Mientras mayor sea el número de respuestas seguidas a una misma tecla, mayor será la probabilidad de refuerzo asociada con la respuesta alterna. De acuerdo al modelo de maximización instantánea, debería observarse que la probabilidad de cambiar de alternativa es una función del número de respuestas que se hayan dado a la misma tecla. Por ejemplo, si el programa es uno concurrente de tecla verde con IV 1’ - tecla roja con IV 3’, el modelo predice la siguiente secuencia de tres respuestas: Verde-Verde-Roja. Por los valores de los programas de intervalo, después de cada dos respuestas seguidas a la opción verde resulta más probable que se otorgue un refuerzo a la opción roja.</p>
<p>En el experimento más citado con este procedimiento, Nevin () no encontró evidencia en favor del modelo de maximización instantánea. Ver Figuras.</p>
<p>imagen</p>
<p>Obsérvese en la figura del panel izquierdo que la probabilidad de refuerzo de la Opción Roja aumenta con la acumulación de elecciones de la Opción Verde por parte del organismo. Al mismo tiempo, en la figura del panel derecho, nótese que la probabilidad de cambiar a la Opción Roja no aumenta con la acumulación de elecciones de la Opción Verde por parte del organismo. Nota: la probabilidad de cambiar de opción se calculó con base al número de oportunidades para cambiar de opción en cada secuencia (run length). Así, estos resultados rompen con el patron de elecciones esperado según el modelo de maximización instantánea.</p>
<p>En un análisis posterior de su experimento original y de los datos de un experimento de Silberberg (), Nevin () encontró que la perseverancia en las opciones de respuesta (independientemente de su probabilidad de refuerzo) era el patrón más frecuentemente observado en ambos experimentos. Los animales tendían a quedarse en la tecla a la que habían respondido anteriormente y no a cambiar como una función del número de respuestas a esa tecla Ver fig.</p>
<p>imagen</p>
</section>
<section id="programas-de-refuerzo-concurrente-rv---iv-de-ensayos-discretos" class="level4" data-number="11.1.1.2">
<h4 data-number="11.1.1.2" class="anchored" data-anchor-id="programas-de-refuerzo-concurrente-rv---iv-de-ensayos-discretos"><span class="header-section-number">11.1.1.2</span> 2. Programas de refuerzo concurrente RV - IV de ensayos discretos</h4>
<p>Un protocolo adicional para evaluar el modelo de maximización local es un programa concurrente de ensayos discretos RV - IV. En estos programas, la probabilidad de refuerzo para las respuestas asociadas a la opción RV es constante, mientras que la probabilidad de refuerzo para la respuesta asociada al programa IV cambia como una función de la última respuesta a esa opción. Una estrategia consistente con el modelo de maximización instantánea consiste en responder a la opción asociada con el programa RV inmediatamente después de recibir un refuerzo en la opción asociada con el programa IV. Este es el momento con menor probabilidad de refuerzo para la opción IV. De igual forma, la probabilidad de un cambio de la opción RV hacia la opción IV debe incrementar como una función del número de respuestas que se han dado a la opción RV.</p>
<p>La siguiente figura x presenta los resultados obtenidos por Williams () usando el protocolo anterior. En primer lugar, Williams encontró que los animales igualaban la frecuencia relativa de respuestas a la frecuencia relativa de refuerzos, pero de manera aún más importante para estas notas: no encontró evidencia de que la respuesta fuese controlada por la probabilidad instantánea de refuerzo. El panel izquierdo de la figura muestra la probabilidad de refuerzo como una función del número de ensayos desde la última respuesta a la opción IV. Puede verse que la probabilidad de refuerzo para un cambio a la tecla IV es creciente; consecuentemente, la probabilidad de una respuesta a la tecla IV también debería incrementar como una función del número de ensayos desde la última respuesta a la opción IV. Sin embargo, el panel derecho de la figura muestra que la probabilidad real u observada de una respuesta al IV es constante o decreciente.</p>
<p>imagen</p>
</section>
</section>
<section id="conclusiones-acerca-del-modelo-de-maximización-instantánea" class="level3" data-number="11.1.2">
<h3 data-number="11.1.2" class="anchored" data-anchor-id="conclusiones-acerca-del-modelo-de-maximización-instantánea"><span class="header-section-number">11.1.2</span> Conclusiones acerca del modelo de maximización Instantánea</h3>
<p>De los experimentos con el protocolo de ensayos discretos recién descritos y muchos otros que no presentamos se pueden alcanzar las siguientes conclusiones:</p>
<ul>
<li>Consistente con la ley del efecto, la probabilidad de que se repita una opción de respuesta incrementa si esta es seguida por un refuerzo.</li>
<li>También se observa un <em>efecto de perseverancia</em>: es más probable que se repita la respuesta a una opción que ya fue elegida en el pasado, independientemente de si esta respuesta es reforzada o no.</li>
<li>Es importante agregar que la consistencia de los resultados descritos también depende de otras variables como el intervalo entre opciones de elección, el cual afecta la memoria del organismo sobre sus elecciones previas.</li>
</ul>
</section>
</section>
<section id="modelo-de-mejoramiento" class="level2" data-number="11.2">
<h2 data-number="11.2" class="anchored" data-anchor-id="modelo-de-mejoramiento"><span class="header-section-number">11.2</span> Modelo de Mejoramiento</h2>
<p>El modelo de mejoramiento de Herrnstein y Vaughan () describe la dinámica de elección en situaciones de elección recurrentes, momento a momento. Como otros modelos de elección basados en el valor de las opciones, el modelo de mejoramiento cuenta con dos componentes:</p>
<ul>
<li><p>El primer componente es la especificación de la variable de decisión a partir de la cual el organismo elige (es decir, la variable que guía la elección de los organismos; ejemplos de estas variables son la probabilidad de refuerzo, el tiempo transcurrido en una opción o las tasas locales de refuerzo, entre otras opciones).</p></li>
<li><p>El segundo componente es <em>la regla de respuesta</em>: esto es, con qué criterio elige el organismo.</p></li>
</ul>
<p>Para el modelo de mejoramiento, la variable de decisión son las tasas locales de refuerzo, a las cuales previamente llamamos como la rentabilidad de las opciones. Esta variable se computa dividiendo el número de refuerzos para cada opción entre el tiempo asignado a cada una de ellas:</p>
<p><span class="math display">\[
\frac {r_i}{T_i}
\]</span></p>
<p>La rentabilidad puede computarse también para respuestas:</p>
<p><span class="math display">\[
\frac {r_i}{R_i}
\]</span></p>
<p>Asumiendo un tiempo total fijo, de acuerdo al modelo de mejoramiento, cada incremento en una unidad de tiempo asignada a una opción tiene como consecuencia la actualización de las dos tasas de refuerzo locales. Al incrementar el tiempo asignado <span class="math inline">\(t_i\)</span> a una de las opciones, la tasa local de refuerzo de esa opción disminuye (dado que el denominador de la rentabilidad de esa opción crece); simultáneamente, este cambio también reduce el tiempo <span class="math inline">\(t_2\)</span> asignado a la otra opción (dado que el tiempo total es fijo), lo cual incrementa la tasa de refuerzo local asociada con la segunda opción (puesto que el denominador de esta segunda rentabilidad se achica).</p>
<p>El segundo componente del modelo de mejoramiento, la regla de elección, es una variante de maximización que consiste en seleccionar la opción con la mejor tasa de refuerzo local dentro de cada oportunidad.</p>
<p>Este modelo describe la elección dentro de un programa concurrente que se construye como un sistema dinámico y de retroalimentación. Es decir, bajo este arreglo, la opción de respuesta que tiene la mayor tasa local de refuerzo va cambiando como una función de la asignación de tiempos y respuestas por parte del organismo. Es por ello que este modelo puede dar cuenta de la dinámica global de acercamiento del organismo al patrón de igualación observado en programas concurrentes IV - IV. Para entender al modelo, tengan presente que al elegir la opción con la mejor tasa de refuerzo local, el organismo está incrementando el tiempo de estancia en esa opción: lo cual aumenta la base temporal <em>t</em> para computar la tasa de refuerzo local de esa opción. Simultáneamente, y dado el tiempo total fijo, este comportamiento reduce el tiempo de estancia en la segunda opción, lo cual incrementa la tasa local de refuerzo de esa segunda opción. De esta forma, cada aumento de una unidad de tiempo de estancia en la mejor opción por parte del organismo, tiene dos consecuencias: reduce la tasa de refuerzo local de esa opción e incrementa la tasa de refuerzo local de la otra opción. La transición del organismo de una opción a la otra ocurre cuando la dirección de la diferencia entre las dos tasas cambia de signo y, básicamente, la opción alterna se vuelve mejor que la opción actual. Pueden observar que en estos programas, el modelo de mejoramiento es uno de retroalimentación y corresponde a un algoritmo cuyo blanco es la reducción de la diferencia entre las dos tasas de refuerzo locales; el seguimiento de este algoritmo a la larga (o en equilibrio) resulta en la igualación global de las tasas de respuesta a las tasas de refuerzo para ambas opciones (el patrón de igualación). Consideren como ejemplo un programa concurrente IV 1 min - IV 2 min. Supongan que al inicio de la sesión de una hora, el organismo asigna la mitad de su tiempo a cada alternativa. Supuesto importante: Vamos a asumir que el animal responde a una tasa moderada que garantiza que en ambos programas de IV el organismo obtendrá el máximo número de reforzadores posibles (para 1 hora), independientemente del tiempo que efectivamente dedique a cada opción durante la sesión. Esto ocurre porque en los programas de intervalo variable, los reforzadores se “acumulan” durante el tiempo que el animal no está respondiendo a esa opción. Por lo tanto, aunque el animal dedique menos de 1 hora a una opción, si este responde de manera suficientemente rápida, efectivamente podría obtener todos los reforzadores correspondientes a 1 hora pero en una menor cantidad de tiempo. Dado este supuesto, las tasas de refuerzo locales para las dos opciones se calculan como el número máximo posible de refuerzos en una hora dividido por la proporción de tiempo realmente asignada a cada opción. Así, la tasa local de refuerzo para la tecla IV 1’ sería de 60 reforzadores máximos / 0.5 hr = 120 refuerzos por hora. Una vez más, esto significa que aunque el animal solo dedica media hora a esta opción, este puede obtener los 60 reforzadores disponibles durante la sesión completa gracias a la acumulación propia de los programas IV. Nótese que si el organismo le asigna toda la hora a responder a este programa, su tasa local de refuerzo será de 60/1 hr = 60 refuerzos por hora. Al reducir el tiempo asignado a esa opción a media hora (0.5 hr), la rentabilidad de esa opción aumenta a 120 refuerzos por hora, aunque el número absoluto de reforzadores (60) permanece constante. Para el IV 2’, la tasa local de refuerzo es de 30 reforzadores máximos / 0.5 hr = 60 refuerzos por hora. Dados estos resultados y de acuerdo al modelo de mejoramiento, el animal debería escoger asignar más tiempo a la opción con el programa IV 1’ que a la opción con el programa IV 2’, ya que la primera presenta una mayor tasa de refuerzo local (120 vs 60). Supongan ahora que como resultado de asignar más tiempo a la opción IV 1’, el organismo termina dedicando el 90% de su tiempo a esta opción. Ahora, para la opción asociada con el IV 1 min, la tasa de refuerzo local sería de 60/0.9 hr = 66.7 refuerzos por hora. En el IV 2 min, la tasa de refuerzo local sería de 30/0.1 hr = 300 refuerzos por hora. Recordamos que los programas en sí no han cambiado: lo único que está modificando la rentabilidad percibida de ambas opciones es la manera en la que el organismo distribuye su tiempo entre ellas. Pueden observar que al incrementar el tiempo asignado al IV 1’, paradójicamente se incrementó la tasa local de refuerzo asociada con la opción IV 2’ (de 60 a 300 refuerzos por hora) y por lo tanto, si el organismo sigue la regla de mejoramiento, su subsecuente elección debe ser la opción del IV 2’. Bajo este modelo, el equilibrio se alcanza cuando la proporción de tiempo asignado a las dos opciones por parte del organismo es de 2/3 para IV 1’ (60/0.666 90) y 1/3 para IV 2’ (30/0.333 90). Lo anterior es aproximadamente igual a “90 refuerzos por hora” en ambas alternativas. Así, en el punto de equilibrio, ambas alternativas ofrecen exactamente la misma tasa de refuerzo local (90 por hora), lo que explica por qué el organismo deja de cambiar su distribución de tiempo entre las opciones tras alcanzar este punto. Este resultado es equivalente a la <strong>igualación</strong> global de tasas relativas de respuesta a las tasas relativas de refuerzo: 0.66 hr/(0.66 hr + 0.33 hr) 60 r/(60 r + 30 r) En el correspondiente simulador, ustedes podrán ver la dinámica del sistema para diferentes valores de programas concurrentes.</p>
<p>Un problema importante del modelo de mejoramiento es que deja sin especificar la ventana temporal que los organismos requieren para computar las tasas de refuerzo locales de las distintas opciones. ¿Estas tasas se estiman hasta finalizar la duración de cada sesión experimental? O bien aún, ¿seguirá el organismo algoritmos menos evidentes? Por ejemplo, ¿reiniciar la computación de las tasas para las dos opciones cada 10 minutos?¿O borrar la historia con las opciones de respuesta experimentadas días atrás? Las respuestas a todas estas preguntas no son evidentes. Y al mismo tiempo, estas tienen importantes implicaciones para la aplicación del modelo a entornos volátiles, los cuales frecuentemente cambian las condiciones de refuerzo para las diferentes opciones a lo largo del tiempo. Este tema será abordado en otras notas.</p>
</section>
<section id="modelo-de-valor-q-de-la-respuesta" class="level2" data-number="11.3">
<h2 data-number="11.3" class="anchored" data-anchor-id="modelo-de-valor-q-de-la-respuesta"><span class="header-section-number">11.3</span> Modelo de Valor <em>Q</em> de la respuesta</h2>
<p>De los modelos que dan cuenta de la elección recurrente, el modelo de valor <em>Q</em> que vimos en las notas x es el más cercano a la ley del efecto original planteada por Thorndike. La variable de decisión de este modelo es el valor <em>Q</em> adquirido por cada opción de respuesta. Este valor representa la integración de la historia de reforzamiento de cada opción que resulta de la regla del error de predicción. Por otra parte, la regla de respuesta bajo este modelo consiste en la elección probabilística de la respuesta con mayor valor <em>Q</em> en cada oportunidad. Presten atención a que en este modelo, cada respuesta adquiere su valor exclusivamente como función de los refuerzos que produce y es independiente del valor de las demás alternativas presentes.</p>
<p>Por consecuente, una predicción importante de este modelo es que cuando al organismo se le presenta la oportunidad de elegir entre dos respuestas con diferentes valores <em>Q</em>, su elección debe ser independiente del contexto donde fue adquirido el valor <em>Q</em> de cada opción. Imaginen que en su ciudad hay tres cadenas de cafeterías (A, B y C). Cerca de su casa y cerca de su trabajo, hay dos sucursales disponibles (digamos que A y B están cerca de su casa; y B y C están cerca de su trabajo). Una de las cadenas de cafetería, la B, tiene una sucursal en los dos escenarios donde ustedes compran café (a la sucursal cerca de su casa le llamaremos B’ y a la sucursal cerca de su trabajo le llamaremos B’’). Las sucursales de la cadena B tienen un logo que las distingue. Digamos que sus menús son similares, por lo que las dos sucursales B, aunque tienen sutiles diferencias en cuanto a su staff, comparten a grandes rasgos el mismo programa de recompensas (B’ = B’’). En cambio, las cafeterías A y C son claramente distinguibles en cuanto a calidad con relación a ambas cafeterías B. En resumen: A es mucho mejor que B (A &gt; B) y C es mucho peor que B (C &lt; B). Sin embargo, un domingo ustedes acuden a otra zona de la ciudad y se dan cuenta de que las dos sucursales de las cafeterías B (B’ y B’’) han sido reubicadas ahora en una misma y nueva zona de la ciudad. Dado que los programa de recompensas de ambas opciones son iguales (B’ = B’’), ustedes deberían ser indiferentes entre ellas. Sin embargo, es posible que los valores percibidos de B’ y de B’’ dependan de cuál era el otro restaurante con el que ambas opciones competían dentro de su contexto previo (A o C).<br>
Una forma de evaluar experimentalmente esta predicción sobre la relevancia del contexto previo de los refuerzos es presentar a los animales con dos situaciones de elección diferentes: Programa concurrente 1: El animal puede elegir entre: Opción A: reforzada con intervalo variable IV(a) Opción B: reforzada con intervalo variable IV(b) Programa concurrente 2: El animal puede elegir entre: Opción A: reforzada con el mismo intervalo variable IV(a) que en la Situación 1 Opción B’: reforzada con un intervalo variable IV(b’) diferente al de la Situación 1 Posteriormente, se evalúa la preferencia del animal entre las opciones A de ambos programas concurrentes, las cuales comparten exactamente el mismo valor de reforzamiento (Q). Bajo este protocolo, cada par de opciones (cada componente o programa concurrente) se encuentra vigente en períodos de tiempo separados dentro de una misma sesión (formalmente a este arreglo se le conoce como programas múltiples de refuerzo). Una vez alcanzado el equilibrio en cada programa concurrente IV - IV: se presenta una nueva combinación de las opciones comunes a ambos programas. De acuerdo a los modelos de refuerzo, de mejoramiento y de valor <span class="math inline">\(Q\)</span>, la elección en los periodos de prueba debe reflejar los valores adquiridos por cada opción individual.</p>
<p>Belke () corrió una versión de este protocolo. Para uno de los componentes de programas concurrentes (Componente A), los valores de las opciones eran Tecla Blanca (IV 20) vs Tecla Roja (IV 40), mientras que para el otro programa concurrente (el Componente B), las opciones eran Tecla Verde con IV 40 vs una Tecla Amarilla con IV 80. Así, para el Componente A, la opción del IV 40 ocurría en el contexto de una opción IV 20 (la Tecla Roja) que era dos veces más rica. Mientras tanto, para el segundo par de estímulos (el Componente B), la opción IV 40 (la Tecla Verde) se presentaba en el contexto de otra opción reforzada con un IV 80 (la Tecla Amarilla), la cual era dos veces menos rica. De acuerdo al modelo <em>Q</em> que no considera el contexto de los reforzadores, las dos opciones de respuesta reforzadas con el IV 40 (las Teclas Roja y Verde) en ambos programas deben tener el mismo valor. Sin embargo, otra posibilidad es que el valor adquirido por una opción de respuesta dependa del contexto de los refuerzos proporcionados a las respuestas alternativas presentes. En este caso, la Tecla Verde reforzada con el IV 40 dentro del contexto de otra opción reforzada con un IV pobre, adquiere un valor más grande que la Tecla Roja, también reforzada con un IV 40 pero que fue entrenada previamente en un contexto con una opción reforzada con un IV más rico.</p>
<p>Contrario a la predicción de indiferencia arrojada por el modelo de refuerzo <em>Q</em>, Belke encontró que los animales sí preferían la opción IV 40 entrenada en el contexto pobre, por encima de la misma opción entrenada en el contexto rico. Esta evidencia sugiere que el impacto de los reforzadores sobre el valor de una respuesta depende de los reforzadores obtenidos por las otras opciones presentes en el pasado (es decir, con qué otros estímulos ha convivido cada estímulo previamente).</p>
<p>Los resultados anteriores son consistentes con la siguiente interpretación más local de la ejecución en programas concurrentes. La interpretación consiste en suponer que en estos programas lo que el animal aprende es el tiempo que debe pasar en una opción antes de cambiar a otra alternativa. Suponemos que estos tiempos se encuentran relacionados linealmente a la tasa de refuerzo en la tecla alternativa: así, mientras más pobre es el programa alterno, mayor será el tiempo que el organismo pasará en una alternativa. De esa forma, en la prueba de Belke, la preferencia por el “IV 40 que fue entrenado con el IV 80” respecto al “mismo IV 40 que fue entrenado con el IV 20” se explica porque en el primer programa concurrente (Componente B), el organismo aprendió que debía pasar más tiempo por visita en la opción IV 40, mientras que en el segundo programa (Componente A), este aprendió que debía pasar menos tiempo por visita en la opción IV 40.</p>
</section>
<section id="reflexiones-finales-sobre-los-modelos-de-elección-basados-en-valor" class="level2" data-number="11.4">
<h2 data-number="11.4" class="anchored" data-anchor-id="reflexiones-finales-sobre-los-modelos-de-elección-basados-en-valor"><span class="header-section-number">11.4</span> Reflexiones Finales Sobre los Modelos de Elección Basados en Valor</h2>
<ul>
<li>La igualación de tasas relativas de respuesta a tasas relativas de refuerzo es un fenómeno muy robusto.</li>
<li>Igualación es el resultado de un proceso estabilizador de retroalimentación, gobernado por las propiedades temporales de los programas de intervalo.</li>
<li>Igualación ilustra la importancia de entender a los programas de refuerzo como restricciones temporales o de respuesta sobre la distribución de comportamientos.</li>
<li>En un nivel molecular, la dinámica del movimiento hacia igualación ilustra la relevancia del principio de refuerzo, entendido como un algoritmo de ascenso de colina, como el que vimos en las notas x. Este algoritmo postula que el sistema compara, en cada oportunidad de respuesta, el valor de las variables de decisión asociadas con cada alternativa y elige aquella con el valor más alto. La distribución del comportamiento entre diferentes opciones (en equilibrio) es el resultado de diversos factores: primero, el seguimiento del algoritmo de ascenso de colina por parte del organismo; segundo, los ajustes que sufre dicho algoritmo al operar bajo las diferentes restricciones impuestas por los distintos programas de refuerzo; y tercero, la regla de aprendizaje de los valores de la variable de decisión. *La importancia del tiempo de estancia reforzado en cada opción sobre la elección de los organismos.</li>
<li>El avance en los modelos de elección requiere de la consideración de protocolos que capturen la incertidumbre y la volatilidad propia de los entornos naturales de los organismos, un tema que quedará para otra nota.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation column-body">
  <div class="nav-page nav-page-previous">
      <a href="./Capítulo 9.html" class="pagination-link" aria-label="Elección Recurrente: Igualación">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Elección Recurrente: Igualación</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link" aria-label="Referencias">
        <span class="nav-page-text">Referencias</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page">
<p>Acerca</p>
</a>
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
<p>Libro Apoyado por los Proyectos <a href="https://dgapa.unam.mx/index.php/fortalecimiento-a-la-docencia/papime">PAPIME</a> PE309624 y PE302221</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/arbouria/Notas-Aprendizaje-y-Comportamiento-Adaptable-I/edit/main/Capítulo 10.qmd" class="toc-action"><i class="bi bi-github"></i>Editar esta página</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>